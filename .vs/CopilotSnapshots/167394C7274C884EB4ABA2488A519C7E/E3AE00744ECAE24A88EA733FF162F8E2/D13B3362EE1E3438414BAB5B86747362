using System.Diagnostics;

namespace allofthesestarshaveareason.Services;

// Interface tanımı
public interface IAnalysisService
{
    Task<string> StartAnalysisJobAsync(IFormFile file);
    Task<AnalysisStatus> GetAnalysisStatusAsync(string jobId);
}

// Durumları tutmak için bir model
public class AnalysisStatus
{
    public string Status { get; set; } = string.Empty;
    public int Progress { get; set; }
    public int? ResultId { get; set; } // İşlem bitince dolu olacak
}

// Implementation
public class AnalysisService : IAnalysisService
{
    // İşlemlerin durumunu saklamak için basit bir sözlük (gerçek projede veritabanı olmalı)
    private static readonly Dictionary<string, AnalysisStatus> _jobs = new();

    public async Task<string> StartAnalysisJobAsync(IFormFile file)
    {
        var jobId = Guid.NewGuid().ToString();

        // Önce dosyanın bir kopyasını sunucuda güvenli bir yere kaydet.
        var uploadDirectory = "uploads";
        if (!Directory.Exists(uploadDirectory))
        {
            Directory.CreateDirectory(uploadDirectory);
        }

        var filePath = Path.Combine(uploadDirectory, $"{jobId}_{file.FileName}");
        using (var stream = new FileStream(filePath, FileMode.Create))
        {
            await file.CopyToAsync(stream);
        }

        // İşlem durumunu "Sırada" olarak kaydet.
        _jobs[jobId] = new AnalysisStatus { Status = "Sırada", Progress = 0 };

        // AĞIR İŞİ ARKA PLANDA BAŞLAT!
        // Bu, web isteğini tıkamaz ve anında arayüze cevap dönmemizi sağlar.
        _ = Task.Run(() => ProcessVideoInBackground(jobId, filePath));

        return jobId;
    }

    public Task<AnalysisStatus> GetAnalysisStatusAsync(string jobId)
    {
        _jobs.TryGetValue(jobId, out var status);
        return Task.FromResult(status ?? new AnalysisStatus { Status = "Bulunamadı", Progress = 0 });
    }

    private async Task ProcessVideoInBackground(string jobId, string filePath)
    {
        try
        {
            // 1. FFmpeg ile sesi ayıkla
            _jobs[jobId].Status = "Ses ayıklanıyor...";
            _jobs[jobId].Progress = 10;
            var audioPath = await ExtractAudioAsync(filePath, jobId);

            // 2. Whisper ONNX ile konuşmayı metne çevir
            _jobs[jobId].Status = "Konuşma metne çevriliyor...";
            _jobs[jobId].Progress = 30;
            // ...transkript oluşturma kodun...
            await Task.Delay(2000); // Simülasyon

            // 3. Sahne tespiti yap
            _jobs[jobId].Status = "Sahneler tespit ediliyor...";
            _jobs[jobId].Progress = 70;
            // ...sahne tespiti kodun...
            await Task.Delay(2000); // Simülasyon

            // 4. Sonuçları veritabanına kaydet
            _jobs[jobId].Status = "Sonuçlar kaydediliyor...";
            _jobs[jobId].Progress = 90;
            // ...veritabanı kaydı...
            await Task.Delay(1000); // Simülasyon

            _jobs[jobId].Status = "Tamamlandı";
            _jobs[jobId].Progress = 100;
            // Tamamlandığında, sonucun ID'sini de ekleyebiliriz ki arayüz bu ID ile sonuçlara ulaşsın.
            _jobs[jobId].ResultId = 123; // Örnek
        }
        catch (Exception ex)
        {
            _jobs[jobId].Status = $"Hata Oluştu: {ex.Message}";
            _jobs[jobId].Progress = 100;
        }
    }

    private async Task<string> ExtractAudioAsync(string videoPath, string jobId)
    {
        var audioPath = Path.Combine("uploads", $"{jobId}.wav");
        var ffmpegPath = "ffmpeg.exe"; // Ensure ffmpeg is installed and accessible in PATH

        var processStartInfo = new ProcessStartInfo
        {
            FileName = ffmpegPath,
            Arguments = $"-i \"{videoPath}\" -vn -acodec pcm_s16le -ar 44100 -ac 2 \"{audioPath}\"",
            RedirectStandardOutput = true,
            RedirectStandardError = true,
            UseShellExecute = false,
            CreateNoWindow = true
        };

        using var process = new Process { StartInfo = processStartInfo };
        process.Start();

        string error = await process.StandardError.ReadToEndAsync();
        await process.WaitForExitAsync();

        if (process.ExitCode != 0)
        {
            throw new Exception($"FFmpeg failed with exit code {process.ExitCode}: {error}");
        }

        return audioPath;
    }
}




