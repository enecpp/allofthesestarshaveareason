using allofthesestarshaveareason.Models;
using allofthesestarshaveareason.Services.Interfaces;
using Microsoft.AspNetCore.Hosting;
using Microsoft.ML.OnnxRuntime;
using Microsoft.ML.OnnxRuntime.Tensors;
using Microsoft.ML.Tokenizers; 
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Threading.Tasks;

namespace allofthosestarshaveareason.Services.Implementations
{
    public class OnnxTextAnalysisService : ITextAnalysisService, IDisposable
    {
        private readonly InferenceSession _session;
        private readonly EnglishBertTokenizer _tokenizer;

        public OnnxTextAnalysisService(IWebHostEnvironment env)
        {
            // Modeli ve tokenizer'ı yükle
            var modelPath = Path.Combine(env.ContentRootPath, "wwwroot", "ml-models", "model.onnx");
            var vocabPath = Path.Combine(env.ContentRootPath, "wwwroot", "ml-models", "vocab.txt");

            _session = new InferenceSession(modelPath);
            _tokenizer = new EnglishBertTokenizer(vocabPath, true);
        }

        public Task<List<SentenceEmbedding>> GenerateEmbeddingsAsync(List<TranscriptSegment> segments)
        {
            var embeddings = new List<SentenceEmbedding>();
            var segmentTexts = segments.Select(s => s.Text).ToList();

            // 1. ADIM: TOKENIZATION
            // Tüm cümleleri modelin anlayacağı sayısal ID'lere dönüştür.
            var tokenizationResult = _tokenizer.Encode(segmentTexts);

            // 2. ADIM: TENSOR OLUŞTURMA
            // Token'ları OnnxRuntime'ın beklediği Tensor formatına çevir.
            var inputIds = new DenseTensor<long>(tokenizationResult.Ids, tokenizationResult.OutputDimensions);
            var attentionMask = new DenseTensor<long>(tokenizationResult.AttentionMask, tokenizationResult.OutputDimensions);
            var tokenTypeIds = new DenseTensor<long>(tokenizationResult.TokenTypeIds, tokenizationResult.OutputDimensions);

            var inputs = new List<NamedOnnxValue>
            {
                NamedOnnxValue.CreateFromTensor("input_ids", inputIds),
                NamedOnnxValue.CreateFromTensor("attention_mask", attentionMask),
                NamedOnnxValue.CreateFromTensor("token_type_ids", tokenTypeIds)
            };

            // 3. ADIM: MODELİ ÇALIŞTIRMA (INFERENCE)
            using var results = _session.Run(inputs);

            // 4. ADIM: SONUCU İŞLEME (MEAN POOLING)
            // Modelin çıktısı olan Tensor'u alıp, cümlenin anlamını temsil eden tek bir vektöre dönüştür.
            var lastHiddenState = results.First().AsTensor<float>();
            for (int i = 0; i < segmentTexts.Count; i++)
            {
                var segmentSpan = lastHiddenState.GetRowSpan(i);
                var pooledVector = MeanPooling(segmentSpan, tokenizationResult.AttentionMask.GetRowSpan(i));

                embeddings.Add(new SentenceEmbedding
                {
                    // SegmentId'yi atamak için TranscriptSegment modeline bir Id alanı eklemek gerekebilir.
                    // SegmentId = segments[i].Id, 
                    Vector = pooledVector
                });
            }

            return Task.FromResult(embeddings);
        }

        public List<TranscriptSegment> FindSimilarSentences(string query, List<TranscriptSegment> allSegments, List<SentenceEmbedding> allEmbeddings)
        {
            // 1. Arama sorgusunu da aynı şekilde vektöre dönüştür.
            var queryEmbedding = GenerateEmbeddingsForSingleText(query);
            if (queryEmbedding == null) return new List<TranscriptSegment>();

            // 2. Benzerlik skorlarını hesapla
            var scoredSegments = new List<(TranscriptSegment segment, double score)>();
            for (int i = 0; i < allEmbeddings.Count; i++)
            {
                var score = CosineSimilarity(queryEmbedding, allEmbeddings[i].Vector);
                scoredSegments.Add((allSegments[i], score));
            }

            // 3. Skorlara göre sırala ve en alakalı olanları döndür
            return scoredSegments
                .OrderByDescending(s => s.score)
                .Take(5) // En iyi 5 sonucu al
                .Select(s => s.segment)
                .ToList();
        }

        // Tek bir metin için embedding oluşturan yardımcı metot
        private float[] GenerateEmbeddingsForSingleText(string text)
        {
            var tokenizationResult = _tokenizer.Encode(text);
            var inputIds = new DenseTensor<long>(tokenizationResult.Ids, tokenizationResult.OutputDimensions);
            var attentionMask = new DenseTensor<long>(tokenizationResult.AttentionMask, tokenizationResult.OutputDimensions);
            var tokenTypeIds = new DenseTensor<long>(tokenizationResult.TokenTypeIds, tokenizationResult.OutputDimensions);

            var inputs = new List<NamedOnnxValue>
            {
                NamedOnnxValue.CreateFromTensor("input_ids", inputIds),
                NamedOnnxValue.CreateFromTensor("attention_mask", attentionMask),
                NamedOnnxValue.CreateFromTensor("token_type_ids", tokenTypeIds)
            };

            using var results = _session.Run(inputs);
            var lastHiddenState = results.First().AsTensor<float>();
            return MeanPooling(lastHiddenState.GetRowSpan(0), tokenizationResult.AttentionMask.GetRowSpan(0));
        }

        // Model çıktısını anlamlı bir cümle vektörüne dönüştüren metot
        private float[] MeanPooling(ReadOnlySpan<float> tokenEmbeddings, ReadOnlySpan<long> attentionMask)
        {
            int tokenCount = attentionMask.Length;
            int embeddingDim = tokenEmbeddings.Length / tokenCount;
            var pooled = new float[embeddingDim];
            int validTokenCount = 0;

            for (int i = 0; i < tokenCount; i++)
            {
                if (attentionMask[i] == 1) // Sadece gerçek token'ları (padding olmayanları) hesaba kat
                {
                    validTokenCount++;
                    for (int j = 0; j < embeddingDim; j++)
                    {
                        pooled[j] += tokenEmbeddings[i * embeddingDim + j];
                    }
                }
            }

            if (validTokenCount == 0) return pooled;
            for (int j = 0; j < embeddingDim; j++)
            {
                pooled[j] /= validTokenCount;
            }

            return pooled;
        }

        // İki vektör arasındaki anlamsal yakınlığı ölçen metot
        private double CosineSimilarity(float[] vec1, float[] vec2)
        {
            double dotProduct = 0.0;
            double mag1 = 0.0;
            double mag2 = 0.0;
            for (int i = 0; i < vec1.Length; i++)
            {
                dotProduct += vec1[i] * vec2[i];
                mag1 += Math.Pow(vec1[i], 2);
                mag2 += Math.Pow(vec2[i], 2);
            }
            return dotProduct / (Math.Sqrt(mag1) * Math.Sqrt(mag2));
        }

        public void Dispose()
        {
            _session?.Dispose();
        }
    }
}